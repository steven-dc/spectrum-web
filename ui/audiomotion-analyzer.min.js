!function (e, t) {
    if ("function" == typeof define && define.amd)
        define("AudioMotionAnalyzer", ["exports"], t);
    else if ("undefined" != typeof exports)
        t(exports);
    else {
        var i = {
            exports: {}
        };
        t(i.exports),
        e.AudioMotionAnalyzer = i.exports.default
    }
}
("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : this, (function (e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = e.AudioMotionAnalyzer = void 0;
        /**!
         * audioMotion-analyzer
         * High-resolution real-time graphic audio spectrum analyzer JS module
         *
         * @version 4.5.2
         * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>
         * @license AGPL-3.0-or-later
         */
        const t = Math.PI,
        i = 2 * t,
        s = t / 2,
        a = 8.17579892,
        n = "dual-combined",
        r = "dual-horizontal",
        o = "single",
        h = "dual-vertical",
        l = "bar-index",
        c = "bar-level",
        d = "gradient",
        _ = "click",
        u = "resize",
        f = "sans-serif",
        g = 10,
        p = "create",
        m = "fschange",
        y = u,
        w = "user",
        v = "#fff",
        b = "#888",
        x = "bark",
        L = "linear",
        S = "log",
        A = "mel",
        B = ["#a35", "#c66", "#e94", "#ed0", "#9d5", "#4d8", "#2cb", "#0bc", "#09c", "#36b"],
        T = [
    [
        "apple",
        {
            "name": "Apple ][",
            "colorStops": [
                {
                    "pos": 0.1667,
                    "color": "#61bb46"
                },
                {
                    "pos": 0.3333,
                    "color": "#fdb827"
                },
                {
                    "pos": 0.5,
                    "color": "#f5821f"
                },
                {
                    "pos": 0.6667,
                    "color": "#e03a3e"
                },
                {
                    "pos": 0.8333,
                    "color": "#963d97"
                },
                {
                    "pos": 1,
                    "color": "#009ddc"
                }
            ],
            "disabled": false
        }
    ],
    [
        "aurora",
        {
            "name": "Aurora",
            "bgColor": "#0e172a",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "hsl( 120, 100%, 50% )"
                },
                {
                    "pos": 1,
                    "color": "hsl( 216, 100%, 50% )"
                }
            ],
            "disabled": false
        }
    ],
    [
        "borealis",
        {
            "name": "Borealis",
            "bgColor": "#0d1526",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "hsl( 120, 100%, 50% )"
                },
                {
                    "pos": 0.5,
                    "color": "hsl( 189, 100%, 40% )"
                },
                {
                    "pos": 1,
                    "color": "hsl( 290, 60%, 40% )"
                }
            ],
            "disabled": false
        }
    ],
    [
        "candy",
        {
            "name": "Candy",
            "bgColor": "#0d0619",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "#ffaf7b"
                },
                {
                    "pos": 0.5,
                    "color": "#d76d77"
                },
                {
                    "pos": 1,
                    "color": "#3a1c71"
                }
            ],
            "disabled": false
        }
    ],
    [
        "classic",
        {
            "name": "Classic",
            "colorStops": [
                "#f00",
                {
                    "color": "#ff0",
                    "level": 0.85,
                    "pos": 0.6
                },
                {
                    "color": "#0f0",
                    "level": 0.475
                }
            ],
            "disabled": false
        }
    ],
    [
        "cool",
        {
            "name": "Cool",
            "bgColor": "#0b202b",
            "colorStops": [
                "hsl( 208, 0%, 100% )",
                "hsl( 208, 100%, 35% )"
            ],
            "disabled": false
        }
    ],
    [
        "dusk",
        {
            "name": "Dusk",
            "bgColor": "#0e172a",
            "colorStops": [
                {
                    "pos": 0.2,
                    "color": "hsl( 55, 100%, 50% )"
                },
                {
                    "pos": 1,
                    "color": "hsl( 16, 100%, 50% )"
                }
            ],
            "disabled": false
        }
    ],
    [
        "miami",
        {
            "name": "Miami",
            "bgColor": "#110a11",
            "colorStops": [
                {
                    "pos": 0.024,
                    "color": "rgb( 251, 198, 6 )"
                },
                {
                    "pos": 0.283,
                    "color": "rgb( 224, 82, 95 )"
                },
                {
                    "pos": 0.462,
                    "color": "rgb( 194, 78, 154 )"
                },
                {
                    "pos": 0.794,
                    "color": "rgb( 32, 173, 190 )"
                },
                {
                    "pos": 1,
                    "color": "rgb( 22, 158, 95 )"
                }
            ],
            "disabled": false
        }
    ],
    [
        "orient",
        {
            "name": "Orient",
            "bgColor": "#100",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "#f00"
                },
                {
                    "pos": 1,
                    "color": "#600"
                }
            ],
            "disabled": false
        }
    ],
    [
        "outrun",
        {
            "name": "Outrun",
            "bgColor": "#101",
            "colorStops": [
                {
                    "pos": 0,
                    "color": "rgb( 255, 223, 67 )"
                },
                {
                    "pos": 0.182,
                    "color": "rgb( 250, 84, 118 )"
                },
                {
                    "pos": 0.364,
                    "color": "rgb( 198, 59, 243 )"
                },
                {
                    "pos": 0.525,
                    "color": "rgb( 133, 80, 255 )"
                },
                {
                    "pos": 0.688,
                    "color": "rgb( 74, 104, 247 )"
                },
                {
                    "pos": 1,
                    "color": "rgb( 35, 210, 255 )"
                }
            ],
            "disabled": false
        }
    ],
    [
        "pacific",
        {
            "name": "Pacific Dream",
            "bgColor": "#051319",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "#34e89e"
                },
                {
                    "pos": 1,
                    "color": "#0f3443"
                }
            ],
            "disabled": false
        }
    ],
    [
        "prism",
        {
            "name": "Prism",
            "colorStops": [
                "#a35",
                "#c66",
                "#e94",
                "#ed0",
                "#9d5",
                "#4d8",
                "#2cb",
                "#0bc",
                "#09c",
                "#36b"
            ],
            "disabled": false
        }
    ],
    [
        "rainbow",
        {
            "name": "Rainbow",
            "dir": "h",
            "colorStops": [
                "#817",
                "#a35",
                "#c66",
                "#e94",
                "#ed0",
                "#9d5",
                "#4d8",
                "#2cb",
                "#0bc",
                "#09c",
                "#36b",
                "#639"
            ],
            "disabled": false
        }
    ],
    [
        "shahabi",
        {
            "name": "Shahabi",
            "bgColor": "#060613",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "#66ff00"
                },
                {
                    "pos": 1,
                    "color": "#a80077"
                }
            ],
            "disabled": false
        }
    ],
    [
        "summer",
        {
            "name": "Summer",
            "bgColor": "#041919",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "#fdbb2d"
                },
                {
                    "pos": 1,
                    "color": "#22c1c3"
                }
            ],
            "disabled": false
        }
    ],
    [
        "sunset",
        {
            "name": "Sunset",
            "bgColor": "#021119",
            "colorStops": [
                {
                    "pos": 0.1,
                    "color": "#f56217"
                },
                {
                    "pos": 1,
                    "color": "#0b486b"
                }
            ],
            "disabled": false
        }
    ],
    [
        "tiedye",
        {
            "name": "Tie Dye",
            "colorStops": [
                {
                    "pos": 0.038,
                    "color": "rgb( 15, 209, 165 )"
                },
                {
                    "pos": 0.208,
                    "color": "rgb( 15, 157, 209 )"
                },
                {
                    "pos": 0.519,
                    "color": "rgb( 133, 13, 230 )"
                },
                {
                    "pos": 0.731,
                    "color": "rgb( 230, 13, 202 )"
                },
                {
                    "pos": 0.941,
                    "color": "rgb( 242, 180, 107 )"
                }
            ],
            "disabled": false
        }
    ]
],
        R = {
            alphaBars: !1,
            ansiBands: !1,
            barSpace: .1,
            bgAlpha: .7,
            channelLayout: o,
            colorMode: d,
            fadePeaks: !1,
            fftSize: 8192,
            fillAlpha: 1,
            frequencyScale: S,
            gradient: T[0][0],
            gravity: 3.8,
            height: void 0,
            ledBars: !1,
            linearAmplitude: !1,
            linearBoost: 1,
            lineWidth: 0,
            loRes: !1,
            lumiBars: !1,
            maxDecibels: -25,
            maxFPS: 0,
            maxFreq: 22e3,
            minDecibels: -85,
            minFreq: 20,
            mirror: 0,
            mode: 0,
            noteLabels: !1,
            outlineBars: !1,
            overlay: !1,
            peakFadeTime: 750,
            peakHoldTime: 500,
            peakLine: !1,
            radial: !1,
            radialInvert: !1,
            radius: .3,
            reflexAlpha: .15,
            reflexBright: 1,
            reflexFit: !0,
            reflexRatio: 0,
            roundBars: !1,
            showBgColor: !0,
            showFPS: !1,
            showPeaks: !0,
            showScaleX: !0,
            showScaleY: !1,
            smoothing: .5,
            spinSpeed: 0,
            splitGradient: !1,
            start: !0,
            trueLeds: !1,
            useCanvas: !0,
            volume: 0,
            weightingFilter: "",
            width: void 0
        },
        k = ["ERR_AUDIO_CONTEXT_FAIL", "Could not create audio context. Web Audio API not supported?"],
        q = ["ERR_INVALID_AUDIO_CONTEXT", "Provided audio context is not valid"],
        C = ["ERR_UNKNOWN_GRADIENT", "Unknown gradient"],
        F = ["ERR_FREQUENCY_TOO_LOW", "Frequency values must be >= 1"],
        M = ["ERR_INVALID_MODE", "Invalid mode"],
        E = ["ERR_REFLEX_OUT_OF_RANGE", "Reflex ratio must be >= 0 and < 1"],
        G = ["ERR_INVALID_AUDIO_SOURCE", "Audio source must be an instance of HTMLMediaElement or AudioNode"],
        z = ["ERR_GRADIENT_INVALID_NAME", "Gradient name must be a non-empty string"],
        D = ["ERR_GRADIENT_NOT_AN_OBJECT", "Gradient options must be an object"],
        O = ["ERR_GRADIENT_MISSING_COLOR", "Gradient colorStops must be a non-empty array"];
        class I extends Error {
            constructor(e, t) {
                const[i, s] = e;
                super(s + (void 0 !== t ? `: ${t}` : "")),
                this.name = "AudioMotionError",
                this.code = i
            }
        }
        const H = (e, t) => console.warn(`${e} is deprecated. Use ${t} instead.`),
        P = e => {
            for (const t in e)
                return !1;
            return !0
        },
        N = (e, t, i = "toLowerCase") => t[Math.max(0, t.indexOf(("" + e)[i]()))],
        W = (e, t, i, s, a) => t + (s - t) * (a - e) / (i - e);
        Array.prototype.findLastIndex || (Array.prototype.findLastIndex = function (e) {
            let t = this.length;
            for (; t-- > 0; )
                if (e(this[t]))
                    return t;
            return -1
        });
        class X {
            constructor(e, t = {}) {
                this._ready = !1,
                this._aux = {},
                this._canvasGradients = [],
                this._destroyed = !1,
                this._energy = {
                    val: 0,
                    peak: 0,
                    hold: 0
                },
                this._flg = {},
                this._fps = 0,
                this._gradients = {},
                this._last = 0,
                this._outNodes = [],
                this._ownContext = !1,
                this._selectedGrads = [],
                this._sources = [],
                e instanceof Element || (P(t) && !P(e) && (t = e), e = null),
                this._ownCanvas = !(t.canvas instanceof HTMLCanvasElement);
                const i = this._ownCanvas ? document.createElement("canvas") : t.canvas;
                i.style = "max-width: 100%;",
                this._ctx = i.getContext("2d");
                for (const[e, t]of T)
                    this.registerGradient(e, t);
                let s;
                if (this._container = e || !this._ownCanvas && i.parentElement || document.body, this._defaultWidth = this._container.clientWidth || 640, this._defaultHeight = this._container.clientHeight || 270, t.source && (s = t.source.context));
                else if (s = t.audioCtx);
                else
                    try {
                        s = new(window.AudioContext || window.webkitAudioContext),
                        this._ownContext = !0
                    } catch (e) {
                        throw new I(k)
                    }
                if (!s.createGain)
                    throw new I(q);
                const a = this._analyzer = [s.createAnalyser(), s.createAnalyser()],
                n = this._splitter = s.createChannelSplitter(2),
                r = this._merger = s.createChannelMerger(2);
                this._input = s.createGain(),
                this._output = s.createGain(),
                t.source && this.connectInput(t.source);
                for (const e of[0, 1])
                    n.connect(a[e], e);
                r.connect(this._output),
                !1 !== t.connectSpeakers && this.connectOutput();
                for (const e of["_scaleX", "_scaleR"])
                    this[e] = document.createElement("canvas").getContext("2d");
                this._fsEl = t.fsElement || i;
                const o = () => {
                    this._fsTimeout || (this._fsTimeout = window.setTimeout((() => {
                                    this._fsChanging || (this._setCanvas(y), this._fsTimeout = 0)
                                }), 60))
                };
                window.ResizeObserver && (this._observer = new ResizeObserver(o), this._observer.observe(this._container)),
                this._controller = new AbortController;
                const h = this._controller.signal;
                window.addEventListener(u, o, {
                    signal: h
                }),
                i.addEventListener("fullscreenchange", (() => {
                        this._fsChanging = !0,
                        this._fsTimeout && window.clearTimeout(this._fsTimeout),
                        this._setCanvas(m),
                        this._fsTimeout = window.setTimeout((() => {
                                    this._fsChanging = !1,
                                    this._fsTimeout = 0
                                }), 60)
                    }), {
                    signal: h
                });
                const l = () => {
                    "suspended" == s.state && s.resume().then((() => window.removeEventListener(_, l)))
                };
                window.addEventListener(_, l),
                document.addEventListener("visibilitychange", (() => {
                        "hidden" != document.visibilityState && (this._frames = 0, this._time = performance.now())
                    }), {
                    signal: h
                }),
                this._setProps(t, !0),
                this.useCanvas && this._ownCanvas && this._container.appendChild(i),
                this._ready = !0,
                this._setCanvas(p)
            }
            get alphaBars() {
                return this._alphaBars
            }
            set alphaBars(e) {
                this._alphaBars = !!e,
                this._calcBars()
            }
            get ansiBands() {
                return this._ansiBands
            }
            set ansiBands(e) {
                this._ansiBands = !!e,
                this._calcBars()
            }
            get barSpace() {
                return this._barSpace
            }
            set barSpace(e) {
                this._barSpace = +e || 0,
                this._calcBars()
            }
            get channelLayout() {
                return this._chLayout
            }
            set channelLayout(e) {
                this._chLayout = N(e, [o, r, h, n]),
                this._input.disconnect(),
                this._input.connect(this._chLayout != o ? this._splitter : this._analyzer[0]),
                this._analyzer[0].disconnect(),
                this._outNodes.length && this._analyzer[0].connect(this._chLayout != o ? this._merger : this._output),
                this._calcBars(),
                this._makeGrad()
            }
            get colorMode() {
                return this._colorMode
            }
            set colorMode(e) {
                this._colorMode = N(e, [d, l, c])
            }
            get fadePeaks() {
                return this._fadePeaks
            }
            set fadePeaks(e) {
                this._fadePeaks = !!e
            }
            get fftSize() {
                return this._analyzer[0].fftSize
            }
            set fftSize(e) {
                for (const t of[0, 1])
                    this._analyzer[t].fftSize = e;
                const t = this._analyzer[0].frequencyBinCount;
                this._fftData = [new Float32Array(t), new Float32Array(t)],
                this._calcBars()
            }
            get frequencyScale() {
                return this._frequencyScale
            }
            set frequencyScale(e) {
                this._frequencyScale = N(e, [S, x, A, L]),
                this._calcBars()
            }
            get gradient() {
                return this._selectedGrads[0]
            }
            set gradient(e) {
                this._setGradient(e)
            }
            get gradientLeft() {
                return this._selectedGrads[0]
            }
            set gradientLeft(e) {
                this._setGradient(e, 0)
            }
            get gradientRight() {
                return this._selectedGrads[1]
            }
            set gradientRight(e) {
                this._setGradient(e, 1)
            }
            get gravity() {
                return this._gravity
            }
            set gravity(e) {
                this._gravity = e > 0 ? +e : this._gravity || R.gravity
            }
            get height() {
                return this._height
            }
            set height(e) {
                this._height = e,
                this._setCanvas(w)
            }
            get ledBars() {
                return this._showLeds
            }
            set ledBars(e) {
                this._showLeds = !!e,
                this._calcBars()
            }
            get linearAmplitude() {
                return this._linearAmplitude
            }
            set linearAmplitude(e) {
                this._linearAmplitude = !!e
            }
            get linearBoost() {
                return this._linearBoost
            }
            set linearBoost(e) {
                this._linearBoost = e >= 1 ? +e : 1
            }
            get lineWidth() {
                return this._lineWidth
            }
            set lineWidth(e) {
                this._lineWidth = +e || 0
            }
            get loRes() {
                return this._loRes
            }
            set loRes(e) {
                this._loRes = !!e,
                this._setCanvas("lores")
            }
            get lumiBars() {
                return this._lumiBars
            }
            set lumiBars(e) {
                this._lumiBars = !!e,
                this._calcBars(),
                this._makeGrad()
            }
            get maxDecibels() {
                return this._analyzer[0].maxDecibels
            }
            set maxDecibels(e) {
                for (const t of[0, 1])
                    this._analyzer[t].maxDecibels = e
            }
            get maxFPS() {
                return this._maxFPS
            }
            set maxFPS(e) {
                this._maxFPS = e < 0 ? 0 : +e || 0
            }
            get maxFreq() {
                return this._maxFreq
            }
            set maxFreq(e) {
                if (e < 1)
                    throw new I(F);
                this._maxFreq = Math.min(e, this.audioCtx.sampleRate / 2),
                this._calcBars()
            }
            get minDecibels() {
                return this._analyzer[0].minDecibels
            }
            set minDecibels(e) {
                for (const t of[0, 1])
                    this._analyzer[t].minDecibels = e
            }
            get minFreq() {
                return this._minFreq
            }
            set minFreq(e) {
                if (e < 1)
                    throw new I(F);
                this._minFreq = +e,
                this._calcBars()
            }
            get mirror() {
                return this._mirror
            }
            set mirror(e) {
                this._mirror = 0 | Math.sign(e),
                this._calcBars(),
                this._makeGrad()
            }
            get mode() {
                return this._mode
            }
            set mode(e) {
                const t = 0 | e;
                if (!(t >= 0 && t <= 10 && 9 != t))
                    throw new I(M, e);
                this._mode = t,
                this._calcBars(),
                this._makeGrad()
            }
            get noteLabels() {
                return this._noteLabels
            }
            set noteLabels(e) {
                this._noteLabels = !!e,
                this._createScales()
            }
            get outlineBars() {
                return this._outlineBars
            }
            set outlineBars(e) {
                this._outlineBars = !!e,
                this._calcBars()
            }
            get peakFadeTime() {
                return this._peakFadeTime
            }
            set peakFadeTime(e) {
                this._peakFadeTime = e >= 0 ? +e : this._peakFadeTime || R.peakFadeTime
            }
            get peakHoldTime() {
                return this._peakHoldTime
            }
            set peakHoldTime(e) {
                this._peakHoldTime = +e || 0
            }
            get peakLine() {
                return this._peakLine
            }
            set peakLine(e) {
                this._peakLine = !!e
            }
            get radial() {
                return this._radial
            }
            set radial(e) {
                this._radial = !!e,
                this._calcBars(),
                this._makeGrad()
            }
            get radialInvert() {
                return this._radialInvert
            }
            set radialInvert(e) {
                this._radialInvert = !!e,
                this._calcBars(),
                this._makeGrad()
            }
            get radius() {
                return this._radius
            }
            set radius(e) {
                this._radius = +e || 0,
                this._calcBars(),
                this._makeGrad()
            }
            get reflexRatio() {
                return this._reflexRatio
            }
            set reflexRatio(e) {
                if ((e = +e || 0) < 0 || e >= 1)
                    throw new I(E);
                this._reflexRatio = e,
                this._calcBars(),
                this._makeGrad()
            }
            get roundBars() {
                return this._roundBars
            }
            set roundBars(e) {
                this._roundBars = !!e,
                this._calcBars()
            }
            get smoothing() {
                return this._analyzer[0].smoothingTimeConstant
            }
            set smoothing(e) {
                for (const t of[0, 1])
                    this._analyzer[t].smoothingTimeConstant = e
            }
            get spinSpeed() {
                return this._spinSpeed
            }
            set spinSpeed(e) {
                e = +e || 0,
                void 0 !== this._spinSpeed && 0 != e || (this._spinAngle = -s),
                this._spinSpeed = e
            }
            get splitGradient() {
                return this._splitGradient
            }
            set splitGradient(e) {
                this._splitGradient = !!e,
                this._makeGrad()
            }
            get stereo() {
                return H("stereo", "channelLayout"),
                this._chLayout != o
            }
            set stereo(e) {
                H("stereo", "channelLayout"),
                this.channelLayout = e ? h : o
            }
            get trueLeds() {
                return this._trueLeds
            }
            set trueLeds(e) {
                this._trueLeds = !!e
            }
            get volume() {
                return this._output.gain.value
            }
            set volume(e) {
                this._output.gain.value = e
            }
            get weightingFilter() {
                return this._weightingFilter
            }
            set weightingFilter(e) {
                this._weightingFilter = N(e, ["", "A", "B", "C", "D", "468"], "toUpperCase")
            }
            get width() {
                return this._width
            }
            set width(e) {
                this._width = e,
                this._setCanvas(w)
            }
            get audioCtx() {
                return this._input.context
            }
            get canvas() {
                return this._ctx.canvas
            }
            get canvasCtx() {
                return this._ctx
            }
            get connectedSources() {
                return this._sources
            }
            get connectedTo() {
                return this._outNodes
            }
            get fps() {
                return this._fps
            }
            get fsHeight() {
                return this._fsHeight
            }
            get fsWidth() {
                return this._fsWidth
            }
            get isAlphaBars() {
                return this._flg.isAlpha
            }
            get isBandsMode() {
                return this._flg.isBands
            }
            get isDestroyed() {
                return this._destroyed
            }
            get isFullscreen() {
                return this._fsEl && (document.fullscreenElement || document.webkitFullscreenElement) === this._fsEl
            }
            get isLedBars() {
                return this._flg.isLeds
            }
            get isLumiBars() {
                return this._flg.isLumi
            }
            get isOctaveBands() {
                return this._flg.isOctaves
            }
            get isOn() {
                return !!this._runId
            }
            get isOutlineBars() {
                return this._flg.isOutline
            }
            get pixelRatio() {
                return this._pixelRatio
            }
            get isRoundBars() {
                return this._flg.isRound
            }
            static get version() {
                return "4.5.2"
            }
            connectInput(e) {
                const t = e instanceof HTMLMediaElement;
                if (!t && !e.connect)
                    throw new I(G);
                const i = t ? this.audioCtx.createMediaElementSource(e) : e;
                return this._sources.includes(i) || (i.connect(this._input), this._sources.push(i)),
                i
            }
            connectOutput(e = this.audioCtx.destination) {
                if (!this._outNodes.includes(e) && (this._output.connect(e), this._outNodes.push(e), 1 == this._outNodes.length))
                    for (const e of[0, 1])
                        this._analyzer[e].connect(this._chLayout != o || e ? this._merger : this._output, 0, e)
            }
            destroy() {
                if (!this._ready)
                    return;
                const {
                    audioCtx: e,
                    canvas: t,
                    _controller: i,
                    _input: s,
                    _merger: a,
                    _observer: n,
                    _ownCanvas: r,
                    _ownContext: o,
                    _splitter: h
                } = this;
                this._destroyed = !0,
                this._ready = !1,
                this.stop(),
                i.abort(),
                n && n.disconnect(),
                this.onCanvasResize = null,
                this.onCanvasDraw = null,
                this._fsEl = null,
                this.disconnectInput(),
                this.disconnectOutput(),
                s.disconnect(),
                h.disconnect(),
                a.disconnect(),
                o && e.close(),
                r && t.remove(),
                this._calcBars()
            }
            disconnectInput(e, t) {
                e ? Array.isArray(e) || (e = [e]) : e = Array.from(this._sources);
                for (const i of e) {
                    const e = this._sources.indexOf(i);
                    if (t && i.mediaStream)
                        for (const e of i.mediaStream.getAudioTracks())
                            e.stop();
                    e >= 0 && (i.disconnect(this._input), this._sources.splice(e, 1))
                }
            }
            disconnectOutput(e) {
                if ((!e || this._outNodes.includes(e)) && (this._output.disconnect(e), this._outNodes = e ? this._outNodes.filter((t => t !== e)) : [], 0 == this._outNodes.length))
                    for (const e of[0, 1])
                        this._analyzer[e].disconnect()
            }
            getBars() {
                return Array.from(this._bars, (({
                            posX: e,
                            freq: t,
                            freqLo: i,
                            freqHi: s,
                            hold: a,
                            peak: n,
                            value: r
                        }) => ({
                            posX: e,
                            freq: t,
                            freqLo: i,
                            freqHi: s,
                            hold: a,
                            peak: n,
                            value: r
                        })))
            }
            getEnergy(e, t) {
                if (void 0 === e)
                    return this._energy.val;
                if (e != +e) {
                    if ("peak" == e)
                        return this._energy.peak;
                    const i = {
                        bass: [20, 250],
                        lowMid: [250, 500],
                        mid: [500, 2e3],
                        highMid: [2e3, 4e3],
                        treble: [4e3, 16e3]
                    };
                    if (!i[e])
                        return null;
                    [e, t] = i[e]
                }
                const i = this._freqToBin(e),
                s = t ? this._freqToBin(t) : i,
                a = this._chLayout == o ? 1 : 2;
                let n = 0;
                for (let e = 0; e < a; e++)
                    for (let t = i; t <= s; t++)
                        n += this._normalizedB(this._fftData[e][t]);
                return n / (s - i + 1) / a
            }
            getOptions(e) {
                Array.isArray(e) || (e = [e]);
                let t = {};
                for (const i of Object.keys(R))
                    e.includes(i) || ("gradient" == i && this.gradientLeft != this.gradientRight ? (t.gradientLeft = this.gradientLeft, t.gradientRight = this.gradientRight) : "start" != i && (t[i] = this[i]));
                return t
            }
            registerGradient(e, t) {
                if ("string" != typeof e || 0 == e.trim().length)
                    throw new I(z);
                if ("object" != typeof t)
                    throw new I(D);
                const {
                    colorStops: i
                } = t;
                if (!Array.isArray(i) || !i.length)
                    throw new I(O);
                const s = i.length,
                a = e => +e != e || e < 0 || e > 1;
                i.forEach(((e, t) => {
                        const n = t / Math.max(1, s - 1);
                        "object" != typeof e ? i[t] = {
                            pos: n,
                            color: e
                        }
                         : a(e.pos) && (e.pos = n),
                        a(e.level) && (i[t].level = 1 - t / s)
                    })),
                i.sort(((e, t) => e.level < t.level ? 1 : e.level > t.level ? -1 : 0)),
                i[0].level = 1,
                this._gradients[e] = {
                    bgColor: t.bgColor || "#111",
                    dir: t.dir,
                    colorStops: i
                },
                this._selectedGrads.includes(e) && this._makeGrad()
            }
            setCanvasSize(e, t) {
                this._width = e,
                this._height = t,
                this._setCanvas(w)
            }
            setFreqRange(e, t) {
                if (e < 1 || t < 1)
                    throw new I(F);
                this._minFreq = Math.min(e, t),
                this.maxFreq = Math.max(e, t)
            }
            setLedParams(e) {
                let t,
                i,
                s;
                e && (t = 0 | e.maxLeds, i = +e.spaceV, s = +e.spaceH),
                this._ledParams = t > 0 && i > 0 && s >= 0 ? [t, i, s] : void 0,
                this._calcBars()
            }
            setOptions(e) {
                this._setProps(e)
            }
            setSensitivity(e, t) {
                for (const i of[0, 2])
                    this._analyzer[i].minDecibels = Math.min(e, t), this._analyzer[i].maxDecibels = Math.max(e, t)
            }
            start() {
                this.toggleAnalyzer(!0)
            }
            stop() {
                this.toggleAnalyzer(!1)
            }
            toggleAnalyzer(e) {
                const t = this.isOn;
                return void 0 === e && (e = !t),
                t && !e ? (cancelAnimationFrame(this._runId), this._runId = 0) : t || !e || this._destroyed || (this._frames = 0, this._time = performance.now(), this._runId = requestAnimationFrame((e => this._draw(e)))),
                this.isOn
            }
            toggleFullscreen() {
                if (this.isFullscreen)
                    document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen && document.webkitExitFullscreen();
                else {
                    const e = this._fsEl;
                    if (!e)
                        return;
                    e.requestFullscreen ? e.requestFullscreen() : e.webkitRequestFullscreen && e.webkitRequestFullscreen()
                }
            }
            _binToFreq(e) {
                return e * this.audioCtx.sampleRate / this.fftSize || 1
            }
            _calcBars() {
                const e = this._bars = [];
                if (!this._ready)
                    return void(this._flg = {
                            isAlpha: !1,
                            isBands: !1,
                            isLeds: !1,
                            isLumi: !1,
                            isOctaves: !1,
                            isOutline: !1,
                            isRound: !1,
                            noLedGap: !1
                        });
                const {
                    _ansiBands: t,
                    _barSpace: i,
                    canvas: s,
                    _chLayout: n,
                    _maxFreq: o,
                    _minFreq: l,
                    _mirror: c,
                    _mode: d,
                    _radial: _,
                    _radialInvert: u,
                    _reflexRatio: f
                } = this,
                p = s.width >> 1,
                m = s.height >> 1,
                y = n == h && !_,
                w = n == r,
                v = d % 10 != 0,
                b = v && this._frequencyScale == S,
                B = this._showLeds && v && !_,
                T = this._lumiBars && v && !_,
                R = this._alphaBars && !T && d != g,
                k = this._outlineBars && v && !T && !B,
                q = this._roundBars && v && !T && !B,
                C = n != h || f > 0 && !T,
                F = s.height - (y && !B ? .5 : 0) >> y,
                M = F * (T || _ ? 1 : 1 - f) | 0,
                E = s.width - p * (w || 0 != c),
                G = y ? s.height - 2 * F : 0,
                z = p * (-1 == c && !w && !_);
                let D = .375 * Math.min(s.width, s.height) * (n == h ? 1 : this._radius) | 0,
                O = Math.min(p, m);
                u && n != h && ([D, O] = [O, D]);
                const I = t => e.push({
                        ...t,
                        peak: [0, 0],
                        hold: [0],
                        alpha: [0],
                        value: [0]
                    }),
                H = e => {
                    const t = this._freqToBin(e, "floor"),
                    i = this._binToFreq(t),
                    s = this._binToFreq(t + 1);
                    return [t, Math.log2(e / i) / Math.log2(s / i)]
                };
                let P,
                N,
                W;
                if (b) {
                    const i = (e, t, i) => +e.toPrecision(i ? Math.max(t, 1 + Math.log10(e) | 0) : t),
                    s = e => {
                        const t = [1, 1.12, 1.25, 1.4, 1.6, 1.8, 2, 2.24, 2.5, 2.8, 3.15, 3.55, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10],
                        i = 0 | Math.log10(e),
                        s = e / 10 ** i;
                        let a = 1;
                        for (; a < t.length && s > t[a]; )
                            a++;
                        return s - t[a - 1] < t[a] - s && a--,
                        (t[a] * 10 ** (i + 5) | 0) / 1e5
                    },
                    n = [0, 24, 12, 8, 6, 4, 3, 2, 1][d],
                    r = t ? 10 ** (3 / (10 * n)) : 2 ** (1 / n),
                    h = r ** .5;
                    let c = t ? 7.94328235 / (n % 2 ? 1 : h) : a;
                    do {
                        let e = c;
                        const a = i(e / h, 4, !0),
                        o = i(e * h, 4, !0),
                        [d, _] = H(a),
                        [u, f] = H(o);
                        e = t ? n < 4 ? s(e) : i(e, e.toString()[0] < 5 ? 3 : 2) : i(e, 4, !0),
                        e >= l && I({
                            posX: 0,
                            freq: e,
                            freqLo: a,
                            freqHi: o,
                            binLo: d,
                            binHi: u,
                            ratioLo: _,
                            ratioHi: f
                        }),
                        c *= r
                    } while (c <= o);
                    P = E / e.length,
                    e.forEach(((e, t) => e.posX = z + t * P));
                    const _ = e[0],
                    u = e[e.length - 1];
                    N = this._freqScaling(_.freqLo),
                    W = E / (this._freqScaling(u.freqHi) - N),
                    _.freqLo < l && (_.freqLo = l, [_.binLo, _.ratioLo] = H(l)),
                    u.freqHi > o && (u.freqHi = o, [u.binHi, u.ratioHi] = H(o))
                } else if (v) {
                    const e = 10 * [0, 24, 12, 8, 6, 4, 3, 2, 1][d],
                    t = e => {
                        switch (this._frequencyScale) {
                        case x:
                            return 1960 / (26.81 / (e + .53) - 1);
                        case A:
                            return 700 * (2 ** e - 1);
                        case L:
                            return e
                        }
                    };
                    P = E / e,
                    N = this._freqScaling(l),
                    W = E / (this._freqScaling(o) - N);
                    for (let i = 0, s = 0; i < e; i++, s += P) {
                        const e = t(N + s / W),
                        i = t(N + (s + P / 2) / W),
                        a = t(N + (s + P) / W),
                        [n, r] = H(e),
                        [o, h] = H(a);
                        I({
                            posX: z + s,
                            freq: i,
                            freqLo: e,
                            freqHi: a,
                            binLo: n,
                            binHi: o,
                            ratioLo: r,
                            ratioHi: h
                        })
                    }
                } else {
                    P = 1,
                    N = this._freqScaling(l),
                    W = E / (this._freqScaling(o) - N);
                    const t = this._freqToBin(l, "floor"),
                    i = this._freqToBin(o);
                    let s = -999;
                    for (let a = t; a <= i; a++) {
                        const t = this._binToFreq(a),
                        i = z + Math.round(W * (this._freqScaling(t) - N));
                        if (i > s)
                            I({
                                posX: i,
                                freq: t,
                                freqLo: t,
                                freqHi: t,
                                binLo: a,
                                binHi: a,
                                ratioLo: 0,
                                ratioHi: 0
                            }), s = i;
                        else if (e.length) {
                            const i = e[e.length - 1];
                            i.binHi = a,
                            i.freqHi = t,
                            i.freq = (i.freqLo * t) ** .5
                        }
                    }
                }
                let X = 0,
                $ = 0;
                if (B) {
                    const e = this._pixelRatio / (window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1),
                    t = [[], [128, 3, .45], [128, 4, .225], [96, 6, .225], [80, 6, .225], [80, 6, .125], [64, 6, .125], [48, 8, .125], [24, 16, .125]],
                    i = this._ledParams,
                    [s, a, n] = i || t[d];
                    let r,
                    o = M;
                    if (i) {
                        const t = 2 * e;
                        let i;
                        r = s + 1;
                        do {
                            r--,
                            i = o / r / (1 + a),
                            $ = i * a
                        } while ((i < t || $ < t) && r > 1)
                    } else {
                        const t = 540 / a;
                        $ = Math.min(a * e, Math.max(2, o / t + .1 | 0))
                    }
                    C && (o += $),
                    i || (r = Math.min(s, o / (2 * $) | 0)),
                    X = n >= 1 ? n : P * n,
                    this._leds = [r, X, $, o / r - $]
                }
                const U = Math.min(P - 1, i * (i > 0 && i < 1 ? P : 1));
                v && (P -= Math.max(B ? X : 0, U)),
                e.forEach(((t, s) => {
                        let a = t.posX,
                        n = P;
                        v && (0 != i || B ? a += Math.max(B ? X : 0, U) / 2 : (a |= 0, n |= 0, s > 0 && a > e[s - 1].posX + e[s - 1].width && (a--, n++)), t.posX = a),
                        t.barCenter = a + (1 == P ? 0 : n / 2),
                        t.width = n
                    }));
                const j = [];
                for (const e of[0, 1]) {
                    const t = n == h ? (F + G) * e : 0,
                    i = t + F,
                    s = t + M - (!B || C ? 0 : $);
                    j.push({
                        channelTop: t,
                        channelBottom: i,
                        analyzerBottom: s
                    })
                }
                this._aux = {
                    analyzerHeight: M,
                    analyzerWidth: E,
                    centerX: p,
                    centerY: m,
                    channelCoords: j,
                    channelHeight: F,
                    channelGap: G,
                    initialX: z,
                    innerRadius: D,
                    outerRadius: O,
                    scaleMin: N,
                    unitWidth: W
                },
                this._flg = {
                    isAlpha: R,
                    isBands: v,
                    isLeds: B,
                    isLumi: T,
                    isOctaves: b,
                    isOutline: k,
                    isRound: q,
                    noLedGap: C
                },
                this._createScales()
            }
            _createScales() {
                if (!this._ready)
                    return;
                const {
                    analyzerWidth: e,
                    initialX: t,
                    innerRadius: n,
                    scaleMin: o,
                    unitWidth: l
                } = this._aux, {
                    canvas: c,
                    _frequencyScale: d,
                    _mirror: _,
                    _noteLabels: u,
                    _radial: g,
                    _scaleX: p,
                    _scaleR: m
                } = this,
                y = p.canvas,
                w = m.canvas,
                b = [],
                x = this._chLayout == r,
                A = this._chLayout == h,
                B = Math.min(c.width, c.height),
                T = ["C", , "D", , "E", "F", , "G", , "A", , "B"],
                R = B / 34 | 0,
                k = y.height >> 1,
                q = R >> 1,
                C = k * (u ? .7 : 1.5),
                F = q * (u ? 1 : 2),
                M = 2 ** (1 / 12);
                if (u || !this._ansiBands && d == S) {
                    let e = a;
                    for (let t = -1; t < 11; t++)
                        for (let i = 0; i < 12; i++) {
                            if (e >= this._minFreq && e <= this._maxFreq) {
                                const s = T[i],
                                a = "C" == s;
                                (s && u && !_ && !x || a) && b.push(u ? [e, s + (a ? t : "")] : e)
                            }
                            e *= M
                        }
                } else
                    b.push(16, 31.5, 63, 125, 250, 500, 1e3, 2e3, 4e3), d == L ? b.push(6e3, 8e3, 1e4, 12e3, 14e3, 16e3, 18e3, 2e4, 22e3) : b.push(8e3, 16e3);
                w.width = w.height = Math.max(.15 * B, (n << 1) + A * R);
                const E = w.width >> 1,
                G = E - .7 * R,
                z = (e, t) => {
                    const a = i * (e / c.width),
                    n = a - s,
                    r = G * Math.cos(n),
                    o = G * Math.sin(n);
                    m.save(),
                    m.translate(E + r, E + o),
                    m.rotate(a),
                    m.fillText(t, 0, 0),
                    m.restore()
                };
                y.width |= 0,
                p.fillStyle = m.strokeStyle = "#000c",
                p.fillRect(0, 0, y.width, y.height),
                m.arc(E, E, E - R / 2, 0, i),
                m.lineWidth = R,
                m.stroke(),
                p.fillStyle = m.fillStyle = v,
                p.font = `${k}px ${f}`,
                m.font = `${q}px ${f}`,
                p.textAlign = m.textAlign = "center";
                let D = -C / 4,
                O = -F;
                for (const i of b) {
                    const[s, a] = Array.isArray(i) ? i : [i, i < 1e3 ? 0 | i : (i / 100 | 0) / 10 + "k"],
                    n = l * (this._freqScaling(s) - o),
                    r = .75 * y.height,
                    h = "C" == a[0],
                    f = k * (!u || _ || x ? 3 : h ? 1.2 : .6);
                    if (p.fillStyle = m.fillStyle = !h || _ || x ? v : "#4f4", u) {
                        const e = d == S,
                        t = d == L;
                        let i = ["C"];
                        if ((e || s > 2e3 || !t && s > 250 || (!g || A) && (!t && s > 125 || s > 1e3)) && i.push("G"), (e || s > 4e3 || !t && s > 500 || (!g || A) && (!t && s > 250 || s > 2e3)) && i.push("E"), (t && s > 4e3 || (!g || A) && (e || s > 2e3 || !t && s > 500)) && i.push("D", "F", "A", "B"), !i.includes(a[0]))
                            continue
                    }
                    n >= D + C / 2 && n <= e && (p.fillText(a, x && -1 == _ ? e - n : t + n, r, f), (x || _ && (n > C || 1 == _)) && p.fillText(a, x && 1 != _ ? e + n : (t || c.width) - n, r, f), D = n + Math.min(f, p.measureText(a).width) / 2),
                    n >= O + F && n < e - F && (z(x && 1 == _ ? e - n : n, a), (x || _ && (n > F || 1 == _)) && z(x && -1 != _ ? e + n : -n, a), O = n)
                }
            }
            _draw(e) {
                this._runId = requestAnimationFrame((e => this._draw(e)));
                const a = e - this._time,
                _ = e - this._last,
                u = this._maxFPS ? 975 / this._maxFPS : 0;
                if (_ < u)
                    return;
                this._last = e - (u ? _ % u : 0),
                this._frames++,
                a >= 1e3 && (this._fps = this._frames / a * 1e3, this._frames = 0, this._time = e);
                const {
                    isAlpha: p,
                    isBands: m,
                    isLeds: y,
                    isLumi: w,
                    isOctaves: v,
                    isOutline: x,
                    isRound: L,
                    noLedGap: S
                } = this._flg, {
                    analyzerHeight: A,
                    centerX: B,
                    centerY: T,
                    channelCoords: R,
                    channelHeight: k,
                    channelGap: q,
                    initialX: C,
                    innerRadius: F,
                    outerRadius: M
                } = this._aux, {
                    _bars: E,
                    canvas: G,
                    _canvasGradients: z,
                    _chLayout: D,
                    _colorMode: O,
                    _ctx: I,
                    _energy: H,
                    _fadePeaks: P,
                    fillAlpha: N,
                    _fps: X,
                    _linearAmplitude: $,
                    _lineWidth: U,
                    maxDecibels: j,
                    minDecibels: Y,
                    _mirror: V,
                    _mode: J,
                    overlay: K,
                    _radial: Q,
                    showBgColor: Z,
                    showPeaks: ee,
                    useCanvas: te,
                    _weightingFilter: ie
                } = this,
                se = this._scaleX.canvas,
                ae = this._scaleR.canvas,
                ne = X * this._peakFadeTime / 1e3,
                re = X ** 2,
                oe = 1e3 * this._gravity,
                he = X * this._peakHoldTime / 1e3,
                le = D == n,
                ce = D == r,
                de = D == h,
                _e = D == o,
                ue = y && this._trueLeds && O == d,
                fe = Q ? G.width : this._aux.analyzerWidth,
                ge = C + fe,
                pe = ee && this._peakLine && J == g,
                me = Q ? M - F : A,
                ye = me / this._pixelRatio,
                [we, ve, be, xe] = this._leds || [];
                H.val > 0 && X > 0 && (this._spinAngle += this._spinSpeed * i / 60 / X);
                const Le = e => {
                    if (this._reflexRatio > 0 && !w && !Q) {
                        let t,
                        i;
                        this.reflexFit || de ? (t = de && 0 == e ? k + q : 0, i = k - A) : (t = G.height - 2 * A, i = A),
                        I.save(),
                        I.globalAlpha = this.reflexAlpha,
                        1 != this.reflexBright && (I.filter = `brightness(${this.reflexBright})`),
                        I.setTransform(1, 0, 0, -1, 0, G.height),
                        I.drawImage(G, 0, R[e].channelTop, G.width, A, 0, t, G.width, i),
                        I.restore()
                    }
                },
                Se = () => {
                    this.showScaleX && (Q ? (I.save(), I.translate(B, T), this._spinSpeed && I.rotate(this._spinAngle + s), I.drawImage(ae, -ae.width >> 1, -ae.width >> 1), I.restore()) : I.drawImage(se, 0, G.height - se.height))
                },
                Ae = e => {
                    const t = e ** 2,
                    i = 424.36,
                    s = 148693636,
                    a = e => 20 * Math.log10(e);
                    switch (ie) {
                    case "A":
                        return 2 + a(s * t ** 2 / ((t + i) * Math.sqrt((t + 11599.29) * (t + 544496.41)) * (t + s)));
                    case "B":
                        return .17 + a(s * t * e / ((t + i) * Math.sqrt(t + 25122.25) * (t + s)));
                    case "C":
                        return .06 + a(s * t / ((t + i) * (t + s)));
                    case "D":
                        const n = ((1037918.48 - t) ** 2 + 1080768.16 * t) / ((9837328 - t) ** 2 + 11723776 * t);
                        return a(e / 68966888496476e-18 * Math.sqrt(n / ((t + 79919.29) * (t + 1345600))));
                    case "468":
                        const r = -4737338981378384e-39 * e ** 6 + 2043828333606125e-30 * e ** 4 - 1.363894795463638e-7 * t + 1,
                        o = 1306612257412824e-34 * e ** 5 - 2118150887518656e-26 * e ** 3 + .0005559488023498642 * e;
                        return 18.2 + a(.0001246332637532143 * e / Math.hypot(r, o))
                    }
                    return 0
                },
                Be = (e, t, i) => {
                    I.beginPath(),
                    I.moveTo(e, t),
                    I.lineTo(e, i),
                    I.stroke()
                },
                Te = e => {
                    if (e && U) {
                        const e = I.globalAlpha;
                        I.globalAlpha = 1,
                        I.stroke(),
                        I.globalAlpha = e
                    }
                },
                Re = e => Math.max(0, (e * we | 0) * (xe + be) - be);
                K && I.clearRect(0, 0, G.width, G.height);
                let ke = 0;
                const qe = E.length,
                Ce = _e ? 1 : 2;
                for (let e = 0; e < Ce; e++) {
                    const {
                        channelTop: s,
                        channelBottom: a,
                        analyzerBottom: n
                    } = R[e],
                    r = this._gradients[this._selectedGrads[e]],
                    o = r.colorStops,
                    h = o.length,
                    _ = !Z || y && !K ? "#000" : r.bgColor,
                    u = de && Q && e ? -1 : 1,
                    m = !e && -1 == V || e && 1 == V,
                    v = !ce || e && 1 != V ? 0 : fe >> (e || !m),
                    S = ce && m ? -1 : 1,
                    M = () => {
                        const t = se.height,
                        i = t >> 1,
                        a = $ ? 100 : j,
                        n = $ ? 0 : Y,
                        r = $ ? 20 : 5,
                        o = A / (a - n),
                        h = -1 != V && (!ce || 0 == e || 1 == V),
                        l = 1 != V && (!ce || e != V);
                        I.save(),
                        I.fillStyle = b,
                        I.font = `${i}px ${f}`,
                        I.textAlign = "right",
                        I.lineWidth = 1;
                        for (let e = a; e > n; e -= r) {
                            const n = s + (a - e) * o,
                            r = e % 2 == 0 | 0;
                            if (r) {
                                const a = n + i * (n == s ? .8 : .35);
                                h && I.fillText(e, .85 * t, a),
                                l && I.fillText(e, (ce ? fe : G.width) - .1 * t, a),
                                I.strokeStyle = b,
                                I.setLineDash([2, 4]),
                                I.lineDashOffset = 0
                            } else
                                I.strokeStyle = "#555", I.setLineDash([2, 8]), I.lineDashOffset = 1;
                            I.beginPath(),
                            I.moveTo(C + t * r * h, .5 + ~~n),
                            I.lineTo(ge - t * r * l, .5 + ~~n),
                            I.stroke()
                        }
                        I.restore()
                    },
                    D = (e, t) => {
                        const i = we[e] + (e < we.length - 1 ? (we[e + 1] - we[e]) * t : 0);
                        return isNaN(i) ? -1 / 0 : i
                    },
                    H = (e, t = S) => t * i * ((e + v) / G.width) + this._spinAngle,
                    X = (e, t, i) => {
                        const s = F + t * u,
                        a = H(e, i);
                        return [B + s * Math.cos(a), T + s * Math.sin(a)]
                    },
                    ae = (e, t, i, s, a) => {
                        I.beginPath();
                        for (const n of V && !ce ? [1, -1] : [S]) {
                            const[r, o] = L ? [H(e, n), H(e + i, n)] : [];
                            I.moveTo(...X(e, t, n)),
                            I.lineTo(...X(e, t + s, n)),
                            L ? I.arc(B, T, F + (t + s) * u, r, o, 1 != n) : I.lineTo(...X(e + i, t + s, n)),
                            I.lineTo(...X(e + i, t, n)),
                            L && !a && I.arc(B, T, F + t * u, o, r, 1 == n)
                        }
                        Te(a),
                        I.fill()
                    },
                    _e = (t = 0, i = 0) => {
                        let s;
                        if (O == d && !ue || J == g)
                            s = z[e];
                        else {
                            const e = O == l ? i % h : o.findLastIndex((e => y ? Re(t) <= Re(e.level) : t <= e.level));
                            s = o[e].color
                        }
                        I.fillStyle = I.strokeStyle = s
                    };
                    if (te) {
                        if (ce && !Q) {
                            const t = fe * (e + m),
                            i = m ? -1 : 1;
                            I.setTransform(i, 0, 0, 1, t, 0)
                        }
                        if (K && !Z || (K && (I.globalAlpha = this.bgAlpha), I.fillStyle = _, 0 != e && (Q || le) || I.fillRect(C, s - q, fe, (K && 1 == this.reflexAlpha ? A : k) + q), I.globalAlpha = 1), !this.showScaleY || w || Q || 0 != e && le || M(), y ? (I.setLineDash([xe, be]), I.lineWidth = E[0].width) : I.lineWidth = x ? Math.min(U, E[0].width / 2) : U, I.save(), !Q) {
                            const e = new Path2D;
                            e.rect(0, s, G.width, A),
                            I.clip(e)
                        }
                    }
                    let we = this._fftData[e];
                    this._analyzer[e].getFloatFrequencyData(we),
                    ie && (we = we.map(((e, t) => e + Ae(this._binToFreq(t))))),
                    I.beginPath();
                    let ve = [];
                    for (let a = 0; a < qe; a++) {
                        const r = E[a], {
                            posX: l,
                            barCenter: d,
                            width: _,
                            freq: u,
                            binLo: f,
                            binHi: m,
                            ratioLo: v,
                            ratioHi: b
                        } = r;
                        let S = Math.max(D(f, v), D(m, b));
                        for (let e = f + 1; e < m; e++)
                            we[e] > S && (S = we[e]);
                        if (S = this._normalizedB(S), r.value[e] = S, ke += S, r.peak[e] > 0 && r.alpha[e] > 0 && (r.hold[e]--, r.hold[e] < 0)) {
                            if (P && !pe) {
                                const t = !p || x && U > 0 ? 1 : p ? r.peak[e] : N;
                                r.alpha[e] = t * (1 + r.hold[e] / ne)
                            } else
                                r.peak[e] += r.hold[e] * oe / re / Math.abs(ye);
                            r.alpha[e] <= 0 && (r.peak[e] = 0)
                        }
                        if (S >= r.peak[e] && (r.peak[e] = S, r.hold[e] = he, r.alpha[e] = !p || x && U > 0 ? 1 : p ? S : N), !te)
                            continue;
                        I.globalAlpha = w || p ? S : x ? N : 1,
                        _e(S, a);
                        const A = w ? me : y ? Re(S) : S * me | 0;
                        if (J == g) {
                            const e = a ? 0 : (this._normalizedB(we[E[1].binLo]) * me + A) / 2;
                            if (Q) {
                                if (0 == a && (ce && I.moveTo(...X(0, 0)), I.lineTo(...X(0, l < 0 ? e : A))), l >= 0) {
                                    const e = [l, A];
                                    I.lineTo(...X(...e)),
                                    ve.push(e)
                                }
                            } else {
                                if (0 == a)
                                    if (-1 != V || ce) {
                                        const e = f ? this._normalizedB(we[f - 1]) * me : A;
                                        I.moveTo(C - U, n - e)
                                    } else
                                        I.moveTo(C, n - (l < C ? e : A));
                                (ce || -1 != V || l >= C) && I.lineTo(l, n - A)
                            }
                        } else if (y) {
                            if (Z && !K && (0 == e || !le)) {
                                const e = I.globalAlpha;
                                I.strokeStyle = "#7f7f7f22",
                                I.globalAlpha = 1,
                                Be(d, s, n),
                                I.strokeStyle = I.fillStyle,
                                I.globalAlpha = e
                            }
                            if (ue) {
                                const e = w ? 0 : o.findLastIndex((e => Re(S) <= Re(e.level)));
                                let t = n;
                                for (let i = h - 1; i >= e; i--) {
                                    I.strokeStyle = o[i].color;
                                    let s = n - (i == e ? A : Re(o[i].level));
                                    Be(d, t, s),
                                    t = s - be
                                }
                            } else
                                Be(d, n, n - A)
                        } else if (l >= C)
                            if (Q)
                                ae(l, 0, _, A, x);
                            else if (L) {
                                const e = _ / 2,
                                s = n + e;
                                I.beginPath(),
                                I.moveTo(l, s),
                                I.lineTo(l, s - A),
                                I.arc(d, s - A, e, t, i),
                                I.lineTo(l + _, s),
                                Te(x),
                                I.fill()
                            } else {
                                const e = x ? I.lineWidth : 0;
                                I.beginPath(),
                                I.rect(l, n + e, _, -A - e),
                                Te(x),
                                I.fill()
                            }
                        const B = r.peak[e],
                        T = r.alpha[e];
                        if (B > 0 && T > 0 && ee && !pe && !w && l >= C && l < ge)
                            if (P ? I.globalAlpha = T : x && U > 0 ? I.globalAlpha = 1 : p && (I.globalAlpha = B), (O == c || ue) && _e(B), y) {
                                const e = Re(B);
                                e >= be && I.fillRect(l, n - e, _, xe)
                            } else if (Q) {
                                if (J != g) {
                                    const e = B * me;
                                    ae(l, e, _, !this._radialInvert || de || e + F >= 2 ? -2 : 2)
                                }
                            } else
                                I.fillRect(l, n - B * me, _, 2)
                    }
                    if (te) {
                        if (I.globalAlpha = 1, J == g) {
                            if (_e(), Q && !ce) {
                                if (V) {
                                    let e;
                                    for (; e = ve.pop(); )
                                        I.lineTo(...X(...e, -1))
                                }
                                I.closePath()
                            }
                            if (U > 0 && I.stroke(), N > 0) {
                                if (Q) {
                                    const e = ce ? H(fe >> 1) : 0,
                                    t = ce ? H(fe) : i;
                                    I.moveTo(...X(ce ? fe >> 1 : 0, 0)),
                                    I.arc(B, T, F, e, t, !ce || !m)
                                } else
                                    I.lineTo(ge, n), I.lineTo(C, n);
                                I.globalAlpha = N,
                                I.fill(),
                                I.globalAlpha = 1
                            }
                            if ((pe || Q && ee) && (ve = [], I.beginPath(), E.forEach(((t, i) => {
                                            let s = t.posX,
                                            a = t.peak[e],
                                            r = i ? "lineTo" : "moveTo";
                                            if (Q && s < 0) {
                                                const t = E[i + 1];
                                                a = W(s, a, t.posX, t.peak[e], 0),
                                                s = 0
                                            }
                                            a *= me,
                                            pe ? (I[r](...Q ? X(s, a) : [s, n - a]), Q && V && !ce && ve.push([s, a])) : a > 0 && ae(s, a, 1, -2)
                                        })), pe)) {
                                let e;
                                for (; e = ve.pop(); )
                                    I.lineTo(...X(...e, -1));
                                I.lineWidth = 1,
                                I.stroke()
                            }
                        }
                        I.restore(),
                        ce && !Q && I.setTransform(1, 0, 0, 1, 0, 0),
                        (!ce && !le || e) && Le(e)
                    }
                }
                if ((e => {
                        H.val = e,
                        H.peak > 0 && (H.hold--, H.hold < 0 && (H.peak += H.hold * oe / re / G.height * this._pixelRatio)),
                        e >= H.peak && (H.peak = e, H.hold = he)
                    })(ke / (qe << Ce - 1)), te && (!V || Q || ce || (I.setTransform(-1, 0, 0, 1, G.width - C, 0), I.drawImage(G, C, 0, B, G.height, 0, 0, B, G.height), I.setTransform(1, 0, 0, 1, 0, 0)), I.setLineDash([]), Se()), this.showFPS) {
                    const e = se.height;
                    I.font = `bold ${e}px ${f}`,
                    I.fillStyle = "#0f0",
                    I.textAlign = "right",
                    I.fillText(Math.round(X), G.width - e, 2 * e)
                }
                this.onCanvasDraw && (I.save(), I.fillStyle = I.strokeStyle = z[0], this.onCanvasDraw(this, {
                        timestamp: e,
                        canvasGradients: z
                    }), I.restore())
            }
            _freqScaling(e) {
                switch (this._frequencyScale) {
                case S:
                    return Math.log2(e);
                case x:
                    return 26.81 * e / (1960 + e) - .53;
                case A:
                    return Math.log2(1 + e / 700);
                case L:
                    return e
                }
            }
            _freqToBin(e, t = "round") {
                const i = this._analyzer[0].frequencyBinCount - 1,
                s = Math[t](e * this.fftSize / this.audioCtx.sampleRate);
                return s < i ? s : i
            }
            _makeGrad() {
                if (!this._ready)
                    return;
                const {
                    canvas: e,
                    _ctx: t,
                    _radial: i,
                    _reflexRatio: s
                } = this, {
                    analyzerWidth: a,
                    centerX: n,
                    centerY: r,
                    initialX: o,
                    innerRadius: l,
                    outerRadius: c
                } = this._aux, {
                    isLumi: d
                } = this._flg,
                _ = this._chLayout == h,
                u = 1 - s,
                f = d ? e.height : e.height * (1 - s * !_) | 0;
                for (const e of[0, 1]) {
                    const h = this._gradients[this._selectedGrads[e]],
                    g = h.colorStops,
                    p = "h" == h.dir;
                    let m;
                    if (m = i ? t.createRadialGradient(n, r, c, n, r, l - (c - l) * _) : t.createLinearGradient(...p ? [o, 0, o + a, 0] : [0, 0, 0, f]), g) {
                        const e = _ && !this._splitGradient && (!p || i);
                        for (let t = 0; t < 1 + e; t++) {
                            const a = g.length - 1;
                            g.forEach(((n, r) => {
                                    let o = n.pos;
                                    if (e && (o /= 2), !_ || d || i || p || (o *= u, !e && o > .5 * u && (o += .5 * s)), 1 == t)
                                        if (i || d) {
                                            o = 1 - (n = g[a - r]).pos / 2
                                        } else
                                            0 == r && o > 0 && m.addColorStop(.5, n.color), o += .5;
                                    m.addColorStop(o, n.color),
                                    _ && r == a && o < .5 && m.addColorStop(.5, n.color)
                                }))
                        }
                    }
                    this._canvasGradients[e] = m
                }
            }
            _normalizedB(e) {
                const t = this._linearAmplitude,
                i = t ? 1 / this._linearBoost : 1,
                s = e => 10 ** (e / 20);
                let a = this.maxDecibels,
                n = this.minDecibels;
                return t && (a = s(a), n = s(n), e = s(e) ** i),
                h = 1,
                (r = (e - n) / (a - n) ** i) <= (o = 0) ? o : r >= h ? h : r;
                var r,
                o,
                h
            }
            _setCanvas(e) {
                if (!this._ready)
                    return;
                const {
                    canvas: t,
                    _ctx: i
                } = this,
                s = this._scaleX.canvas,
                a = window.devicePixelRatio / (this._loRes + 1);
                let n = window.screen.width * a,
                r = window.screen.height * a;
                90 == Math.abs(window.orientation) && n < r && ([n, r] = [r, n]);
                const o = this.isFullscreen,
                h = o && this._fsEl == t,
                l = h ? n : (this._width || this._container.clientWidth || this._defaultWidth) * a | 0,
                c = h ? r : (this._height || this._container.clientHeight || this._defaultHeight) * a | 0;
                this._pixelRatio = a,
                this._fsWidth = n,
                this._fsHeight = r,
                e != p && t.width == l && t.height == c || (t.width = l, t.height = c, this.overlay || (i.fillStyle = "#000", i.fillRect(0, 0, l, c)), i.lineJoin = "bevel", s.width = l, s.height = Math.max(20 * a, Math.min(l, c) / 32 | 0), this._calcBars(), this._makeGrad(), void 0 !== this._fsStatus && this._fsStatus !== o && (e = m), this._fsStatus = o, this.onCanvasResize && this.onCanvasResize(e, this))
            }
            _setGradient(e, t) {
                if (!this._gradients.hasOwnProperty(e))
                    throw new I(C, e);
                [0, 1].includes(t) || (this._selectedGrads[1] = e, t = 0),
                this._selectedGrads[t] = e,
                this._makeGrad()
            }
            _setProps(e, t) {
                const i = ["onCanvasDraw", "onCanvasResize"],
                s = Object.keys(R).filter((e => "start" != e)).concat(i, ["gradientLeft", "gradientRight", "stereo"]);
                (t || void 0 === e) && (e = {
                        ...R,
                        ...e
                    });
                for (const t of Object.keys(e))
                    i.includes(t) && "function" != typeof e[t] ? this[t] = void 0 : s.includes(t) && (this[t] = e[t]);
                void 0 !== e.start && this.toggleAnalyzer(e.start)
            }
        }
        e.AudioMotionAnalyzer = X;
        e.default = X
    }));
